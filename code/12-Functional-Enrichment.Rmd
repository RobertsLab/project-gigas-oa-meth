---
title: "Functional Enrichment"
author: "Yaamini Venkataraman"
output: html_document
---

In this script, I'll characterize general patterns of GOterms associated with genic DML, perform a functional enrichment with `topGO`, then visualize enrichment results with `simplifyEnrichment`.

# Prepare R Markdown file

```{r setup, include=FALSE}
knitr::opts_chunk$set(echo = TRUE)
knitr::opts_knit$set(root.dir = "/Users/yaaminivenkataraman/Documents/project-gigas-oa-meth/output/12-functional-enrichment") #Set root directory
```

# Install packages

```{r}
require(BiocManager)
BiocManager::install("topGO")
BiocManager::install("simplifyEnrichment") #Needs newest R Version (4.1.0)
```

```{r}
require(topGO)
require(simplifyEnrichment)
```

```{r}
require(tidyverse)
```

# Obtain session information

```{r}
sessionInfo()
```

# Describe GO terms associated with DML

Before launching into enrichment, I want to create lists of GOterms associated with DML for descriptive purposes. I'll need to remove the DML that overlap with SNPs to do this, since I only want to look at functions for DML solely associated with pH treatment, and not pH AND genetic information.

## All DML

### Remove overlaps with C/T SNPs

```{r}
allDMLGOterms <- read.table("../11-GOterm-annotation/DML-pH-50-Cov5-All.GeneIDs.geneOverlap.transcriptIDs.GOAnnot", header = FALSE, sep = "\t", col.names = c("transcript", "geneID", "chr", "start", "end", "meth.diff","GOID", "GOterm", "GOSlim", "GOcat")) #Import list of GO term annotations for all DML
allDMLGOterms$chrStartEnd <- paste(allDMLGOterms$chr, "-", allDMLGOterms$start, "-", allDMLGOterms$end, sep = "") #Create a column with chr, start, and end information separated by "-"
head(allDMLGOterms)
```

```{r}
uniqueSNPAll <- read.table("../10_DML-characterization/DML-pH-50-Cov5-All-unique-CT-SNPs.bed", header = FALSE, sep = "\t", col.names = c("chr", "start", "end", "meth.diff")) #Import overlaps between unique C/T SNPs and all DML produced with bedtools
uniqueSNPAll$chrStartEnd <- paste(uniqueSNPAll$chr, "-", uniqueSNPAll$start, "-", uniqueSNPAll$end, sep = "") #Create a column with chr, start, and end information separated by "-"
head(uniqueSNPAll) #Confirm import
```

```{r}
allDMLGOterms <- left_join(x = allDMLGOterms, y = uniqueSNPAll, by = "chrStartEnd") #Add all columns from uniqueSNPAll to allDMLGOterms
allDMLGOtermsFiltered <- filter(allDMLGOterms, is.na(chr.y) == "TRUE")  %>%
  select(!c(chr.y, start.y, end.y, meth.diff.y)) #Keep all rows where chr.y has an "NA", since this indicates there was no matching entry in the DML-SNP overlap dataframe. Then drop chr.y, start.y, end.y, and meth.diff.y
length(allDMLGOtermsFiltered[,1]) #17810 rows without SNP overlaps
colnames(allDMLGOtermsFiltered) <- c("transcript", "geneID", "chr", "start", "end", "meth.diff","GOID", "GOterm", "GOSlim", "GOcat", "chrStartEnd") #Rename columns for consistency
head(allDMLGOtermsFiltered) #Confirm formatting
```

```{r}
length(unique(allDMLGOtermsFiltered$geneID)) #339 annotated genes
length(unique(allDMLGOtermsFiltered$chrStartEnd)) #437 DML in annotated genes
```

### Summarize GOterms

```{r}
allDMLGOtermCounts <- as.data.frame(table(allDMLGOtermsFiltered$GOID)) #Create table with GOID and counts
colnames(allDMLGOtermCounts) <- c("GOID", "Freq") #Add column names
range(allDMLGOtermCounts$Freq) #Get range of GOID frequency
nrow(allDMLGOtermCounts) #Number of unique GOIDs associated with all-DML
```

```{r}
allDMLGOtermsBP <- allDMLGOtermsFiltered %>% filter(., allDMLGOtermsFiltered$GOcat == "P") #Filter biological process terms
allDMLGOtermCountsBP <- as.data.frame(table(allDMLGOtermsBP$GOID)) #Count GOIDs
colnames(allDMLGOtermCountsBP) <- c("GOID", "Freq") #Add column names
allDMLGOtermCountsBP <- allDMLGOtermCountsBP %>% filter(allDMLGOtermCountsBP$Freq != 0)
range(allDMLGOtermCountsBP$Freq) #Get range of GOID frequency
nrow(allDMLGOtermCountsBP) #Number of unique GOIDs associated with all-DML
```

```{r}
write.csv(allDMLGOtermCountsBP, "pH-BP-GOterms.csv", quote = FALSE, row.names = FALSE)
```

## Female-DML

```{r}
femaleDMLGOterms <- read.table("../11-GOterm-annotation/DML-pH-75-Cov5-Fem.GeneIDs.geneOverlap.transcriptIDs.GOAnnot", header = FALSE, sep = "\t", col.names = c("transcript", "geneID", "chr", "start", "end", "GOID", "GOterm", "GOSlim", "GOcat")) #Import list of GO term annotations for female DML
head(femaleDMLGOterms)
```

```{r}
femaleDMLGOtermCounts <- as.data.frame(table(femaleDMLGOterms$GOID)) #Create table with GOID and counts
colnames(femaleDMLGOtermCounts) <- c("GOID", "Freq") #Add column names
range(femaleDMLGOtermCounts$Freq) #Get range of GOID frequency
nrow(femaleDMLGOtermCounts) #Number of unique GOIDs associated with female-DML
```

```{r}
femaleDMLGOtermsBP <- femaleDMLGOterms %>% filter(., femaleDMLGOterms$GOcat == "P") #Filter biological process terms
femaleDMLGOtermCountsBP <- as.data.frame(table(femaleDMLGOtermsBP$GOID)) #Count GOIDs
colnames(femaleDMLGOtermCountsBP) <- c("GOID", "Freq") #Add column names
femaleDMLGOtermCountsBP <- femaleDMLGOtermCountsBP %>% filter(femaleDMLGOtermCountsBP$Freq != 0)
range(femaleDMLGOtermCountsBP$Freq) #Get range of GOID frequency
nrow(femaleDMLGOtermCountsBP) #Number of unique GOIDs associated with female-DML
```

# Gene enrichment with `topGO`

Following protocol from [Chandra Rajan et al. 2021](https://onlinelibrary.wiley.com/doi/full/10.1111/gcb.15675#support-information-section). Script found [here](https://onlinelibrary-wiley-com.offcampus.lib.washington.edu/action/downloadSupplement?doi=10.1111%2Fgcb.15675&file=gcb15675-sup-0002-FileS2.txt).

## Load data for gene enrichment

```{r}
geneID2GO <- readMappings(file = "../11-GOterm-annotation/geneid2go-union5x.tab") #Loading the GO annotations and GeneIDs. Each line has one transcript ID and all associated GOterms
str(head(geneID2GO)) #Confirm file structure
```

```{r}
geneNames <- names(geneID2GO) #Extract names to use as gene universe
head(geneNames)
```

## All DML

```{r}
allGenes <- allDMLGOtermsFiltered$transcript #Extract transcript ID from dataframe that does not include SNP-DML overlaps
allGeneList <- factor(as.integer(geneNames %in% allGenes))
names(allGeneList) <- allGenes
str(allGeneList)
```

### Biological processes

```{r}
allGOdataBP <- new("topGOdata", ontology = "BP", allGenes = allGeneList,
                      annot = annFUN.gene2GO, gene2GO = geneID2GO) #Create biological process topGO object
allGOdataBP #Get summary of object
```

Available genes have annotations, but feasible ones are linked to the GO hierarchy that topGO uses (I think...see [this link](https://avrilomics.blogspot.com/2015/07/using-topgo-to-test-for-go-term.html)).

```{r}
test.stat <- new("classicCount", testStatistic = GOFisherTest, name = "Fisher test")
resultFisher.allBP <- getSigGroups(allGOdataBP, test.stat)
resultFisher.allBP
```

```{r}
pvalFis.allBP <- score(resultFisher.allBP) #Extract p-values
head(pvalFis.allBP)
hist(pvalFis.allBP, 50, xlab = "p-values") #Plot histogram of p-values
```

```{r}
allRes.allBP <- GenTable(allGOdataBP, classic = resultFisher.allBP, ranksOf = "classic", orderBy = "classic", topNodes = length(pvalFis.allBP)) #Create a statistical results table with statistical test results. Order by p-value (classic), and include all results (topNodes)
head(allRes.allBP)
```

```{r}
write.csv(allRes.allBP, "all-BP-FisherTestResults.csv", quote = FALSE, row.names = FALSE) #Save dataframe
```

#### Match enriched GOterms with general annotation information and product ID

```{r}
sigRes.allBP <- allRes.allBP[1:10,c(1, 6)] #Filter significantly enriched GOterms, only keep GOID and p-value
colnames(sigRes.allBP) <- c("GOID", "p.value") #Change column names
head(sigRes.allBP)
```

```{r}
sigRes.allBPAnnot <- left_join(sigRes.allBP, allDMLGOtermsBP, by = "GOID") #Additional annotations. Use left join to keep GOterms that may not have matching annotations.
nrow(sigRes.allBPAnnot) #Count the number of rows
sigRes.allBPAnnot <- unique(sigRes.allBPAnnot[,-11]) #Drop GOcat column and retain only unique lines 
length(unique(sigRes.allBPAnnot$geneID)) #8 unique genes
length(unique(sigRes.allBPAnnot$transcript)) #35 unique transcripts
head(sigRes.allBPAnnot) #Confirm formatting
```

```{r}
write.csv(sigRes.allBPAnnot, "all-BP-EnrichedGO-DML-withTranscript.csv", quote = FALSE, row.names = FALSE) #Save dataframe
```

```{r}
sigRes.allBPAnnotnoT <- unique(sigRes.allBPAnnot[,-3]) #Drop transcript column and keep only unique rows
head(sigRes.allBPAnnotnoT) #Confirm formatting
```
```{r}
write.csv(sigRes.allBPAnnotnoT, "all-BP-EnrichedGO-DML.csv", quote = FALSE, row.names = FALSE) #Save dataframe
```

```{r}
geneProductIDs <- read.delim("../11-GOterm-annotation/cgigas_uk_roslin_v1_rna_from_genomic_annot.transcript.tab", sep = "\t", header = FALSE, col.names = c("transcript", "product")) #Import transcript and gene product information
head(geneProductIDs) #Confirm import
```
```{r}
sigRes.allBPProduct <- left_join(sigRes.allBPAnnot, geneProductIDs, by = "transcript") #Add product annotations and retain rows that may not have annotations
nrow(sigRes.allBPProduct) == nrow(sigRes.allBPAnnot) #Confirm all transcripts have an annotation
head(sigRes.allBPProduct) #Confirm formatting
```

```{r}
write.csv(sigRes.allBPProduct, "all-BP-EnrichedGO-DML-Product.csv", quote = FALSE, row.names = FALSE) #Save dataframe
```

### Cellular components

```{r}
allGOdataCC <- new("topGOdata", ontology = "CC", allGenes = allGeneList,
                      annot = annFUN.gene2GO, gene2GO = geneID2GO) #Create biological process topGO object
allGOdataCC #Get summary of object
```

```{r}
resultFisher.allCC <- getSigGroups(allGOdataCC, test.stat)
resultFisher.allCC
```

```{r}
pvalFis.allCC <- score(resultFisher.allCC) #Extract p-values
head(pvalFis.allCC)
hist(pvalFis.allCC, 50, xlab = "p-values") #Plot histogram of p-values
```

```{r}
allRes.allCC <- GenTable(allGOdataCC, classic = resultFisher.allCC, ranksOf = "classic", orderBy = "classic", topNodes = length(pvalFis.allCC)) #Create a statistical results table with statistical test results. Order by p-value (classic), and include all results (topNodes)
head(allRes.allCC)
```

```{r}
write.csv(allRes.allCC, "all-CC-FisherTestResults.csv", quote = FALSE, row.names = FALSE) #Save dataframe
```

#### Match enriched GOterms with general annotation information

```{r}
sigRes.allCC <- allRes.allCC[1:4,c(1, 6)] #Filter significantly enriched GOterms, only keep GOID and p-value
colnames(sigRes.allCC) <- c("GOID", "p.value") #Change column names
head(sigRes.allCC)
```

```{r}
allDMLGOtermsCC <- allDMLGOtermsFiltered %>% filter(., allDMLGOtermsFiltered$GOcat == "C") #Filter  cellular component terms
head(allDMLGOtermsCC) #Confirm formatting
```

```{r}
sigRes.allCCAnnot <- merge(sigRes.allCC, allDMLGOtermsCC, by = "GOID") #Additional annotations
sigRes.allCCAnnot <- unique(sigRes.allCCAnnot[,-11]) #Drop GOcat column and retain only unique lines 
length(unique(sigRes.allCCAnnot$geneID)) #2 unique genes
length(unique(sigRes.allCCAnnot$transcript)) #15 unique transcripts
head(sigRes.allCCAnnot) #Confirm formatting
```

```{r}
write.csv(sigRes.allCCAnnot, "all-CC-EnrichedGO-DML-withTranscript.csv", quote = FALSE, row.names = FALSE) #Save dataframe
```

```{r}
sigRes.allCCProduct <- merge(sigRes.allCCAnnot, geneProductIDs, by = "transcript") #Add product annotations
head(sigRes.allCCProduct) #Confirm formatting
```

```{r}
write.csv(sigRes.allCCProduct, "all-CC-EnrichedGO-DML-Product.csv", quote = FALSE, row.names = FALSE) #Save dataframe
```

```{r}
sigRes.allCCAnnotnoT <- unique(sigRes.allCCAnnot[,-3]) #Drop transcript column and keep only unique rows
head(sigRes.allCCAnnotnoT) #Confirm formatting
```

```{r}
write.csv(sigRes.allCCAnnotnoT, "all-CC-EnrichedGO-DML.csv", quote = FALSE, row.names = FALSE) #Save dataframe
```

### Molecular function

```{r}
allGOdataMF <- new("topGOdata", ontology = "MF", allGenes = allGeneList,
                      annot = annFUN.gene2GO, gene2GO = geneID2GO) #Create biological process topGO object
allGOdataMF #Get summary of object
```

```{r}
resultFisher.allMF <- getSigGroups(allGOdataMF, test.stat) #Extract significant GOterms using Fisher exact test
resultFisher.allMF #Get results summary
```

## Female-DML

```{r}
femaleGenes <- femaleDMLGOterms$transcript #Extract transcript ID
femaleGeneList <- factor(as.integer(geneNames %in% femaleGenes))
names(femaleGeneList) <- femaleGenes
str(femaleGeneList)
```

### Biological processes

```{r}
femaleGOdataBP <- new("topGOdata", ontology = "BP", allGenes = femaleGeneList,
                      annot = annFUN.gene2GO, gene2GO = geneID2GO) #Create biological process topGO object
femaleGOdataBP #Get summary of object
```

Available genes have annotations, but feasible ones are linked to the GO hierarchy that topGO uses (I think...see [this link](https://avrilomics.blogspot.com/2015/07/using-topgo-to-test-for-go-term.html)).

```{r}
test.stat <- new("classicCount", testStatistic = GOFisherTest, name = "Fisher test")
resultFisher.femaleBP <- getSigGroups(femaleGOdataBP, test.stat)
resultFisher.femaleBP
```

### Cellular components

```{r}
femaleGOdataCC <- new("topGOdata", ontology = "CC", allGenes = femaleGeneList,
                      annot = annFUN.gene2GO, gene2GO = geneID2GO) #Create biological process topGO object
femaleGOdataCC #Get summary of object
```

```{r}
resultFisher.femaleCC <- getSigGroups(femaleGOdataCC, test.stat)
resultFisher.femaleCC
```

### Molecular function

```{r}
femaleGOdataMF <- new("topGOdata", ontology = "MF", allGenes = femaleGeneList,
                      annot = annFUN.gene2GO, gene2GO = geneID2GO) #Create biological process topGO object
femaleGOdataMF #Get summary of object
```

```{r}
resultFisher.femaleMF <- getSigGroups(femaleGOdataMF, test.stat) #Extract significant GOterms using Fisher exact test
resultFisher.femaleMF #Get results summary
```

# Figures

I will use `simplifyEnrichment` to create heatmaps that cluster GO terms by semantic similarity.

```{bash}
mkdir figures
```

## Biological processes

```{r}
matBP <- GO_similarity(go_id = sigRes.allBP$GOID, ont = "BP") #Calculate the semantic similarity matrix using the Rel method (default)
```

```{r}
#pdf("figures/simplifyEnrichment-BP.pdf", width = 11, height = 8.5) #Save figure

simplifyGO(matBP,
           column_title = "", col = rev(plotColors), fontsize_range = c(10,40),
           word_cloud_grob_param = list(col = "black", max_width = 25)) #Plot GOterms based on semantic similarity. Do not include a column title. Set colors to be plot colors, and set fontsize to range from 10 to 40. Pass arguments to word_cloud_grob_param to dictate the colors of the words and maximum width

#Clusters 2-5 are probably all related to eachother (development), so I would argue there are only two clusters.

#dev.off()
```

```{r}
dfBP <- simplifyGO(matBP, plot = FALSE) #Cluster GOterms by semantic similarity
colnames(dfBP) <- c("GOID", "GOterm", "SEcluster") #Modify column names
head(dfBP) #Dataframe with GOIDs, GOterms, and cluster
sort(table(dfBP$SEcluster)) #Obtain size of clusters
```

```{r}
dfBP
```

### Merge with product information

```{r}
sigRes.allBPCluster <- left_join(sigRes.allBPProduct, dfBP, by = "GOID") #Add cluster information to product annotations
nrow(sigRes.allBPCluster) == nrow(sigRes.allBPProduct) #Confirm all rows have a cluster ID
sigRes.allBPCluster <- sigRes.allBPCluster[,-c(9, 12)] #Remove duplicate columns
head(sigRes.allBPCluster)
```

```{r}
write.csv(sigRes.allBPCluster, "all-BP-EnrichedGO-DML-Cluster.csv", row.names = FALSE, quote = FALSE) #Save
```

## Cellular components

```{r}
matCC <- GO_similarity(go_id = sigRes.allCC$GOID, ont = "CC") #Calculate the semantic similarity matrix using the Rel method (default)
```

```{r}
#pdf("figures/simplifyEnrichment-CC.pdf", width = 11, height = 8.5) #Save figure

simplifyGO(matCC,
           column_title = "", col = rev(plotColors), fontsize_range = c(10,40),
           word_cloud_grob_param = list(col = "black", max_width = 25)) #Plot GOterms based on semantic similarity. Do not include a column title. Set colors to be plot colors, and set fontsize to range from 10 to 40. Pass arguments to word_cloud_grob_param to dictate the colors of the words and maximum width

#dev.off()
```

```{r}
dfCC <- simplifyGO(matCC, plot = FALSE) #Cluster GOterms by semantic similarity
head(dfCC) #Dataframe with GOIDs, GOterms, and cluster
sort(table(dfCC$cluster)) #Obtain size of clusters. I won't annotate with cluster information for CC since there is only one cluster.
```

```{r}
save.image("../../project-gigas-oa-meth.RData") #Save R Data
```

